/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>
#include <cmath>
/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>
#include <cmath>

#include <vector>
#include <map>
#include <set>

#include <algorithm>
using namespace std;
class HamiltonianFlights {
public:
  const int MOD = 1000000007;
  int f(int n, int k){
    return n & (1 << k);
  }
  void solve(std::istream &in, std::ostream &out) {
    int n, m;
    in >> n >> m;
    int pwr = 1 << n;
    vector<vector<int>> adj;
    adj.resize(n);
    for (int i = 0; i < m; i++){
      int u, v;
      in >> u >> v;
      u--;
      v--;
      adj[v].push_back(u);
    }
    int dp[pwr][n];
    for(int i = 0; i < pwr; i++){
      for(int j = 0; j < n; j++){
        dp[i][j] = 0;
      }
    }
    dp[1][0] = 1;
    for(int i = 3; i < pwr; i++){
      for(int j = 0; j < n; j++){
        if(i & (1 << j)){
          for(int k: adj[j]){
            if(i && (1 << k)){
              dp[i][j] += dp[i - (1 << j)][k];
              if(dp[i][j] > MOD){
                dp[i][j] -= MOD;
              }
            }
          }
        }
      }
    }
    out << dp[pwr - 1][n - 1] << endl;
  }
};

int main() {
  ios_base::sync_with_stdio(false);
        cin.tie(NULL);
	HamiltonianFlights solver;
        std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
