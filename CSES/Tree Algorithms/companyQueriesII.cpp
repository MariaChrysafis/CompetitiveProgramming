/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>

#include <iostream>
#include <vector>
#include <cmath>
using namespace std;
class CompanyQueriesII {
public:
  struct Tree{
    int cntr;
    vector<vector<int>> adj;
    vector<vector<int>> up;
    vector<int> f, s;
    int n, l;
    /*
     * up[i][j] is the 2^jth ancestor above the node i
     */
    void dfs(int u, int prev){
      f[u] = cntr;
      cntr++;
      up[u][0] = prev;
      for(int i = 1; i <= l; i++){
        up[u][i] = up[up[u][i - 1]][i - 1];
      }
      for(int v: adj[u]){
        if(v != prev){
          dfs(v,u);
        }
      }
      s[u] = cntr;
      cntr++;
    }
    bool isAncestor(int u, int v){
      return f[u] <= f[v] && s[u] >= s[v];
    }
    int lca(int u, int v){
      if(isAncestor(u,v)){
        return u;
      }
      if(isAncestor(v,u)){
        return v;
      }
      for(int i = l; i >= 0; i--){
        if(!isAncestor(up[u][i],v)){
          u = up[u][i];
        }
      }
      return up[u][0];
    }
  };
  void solve(std::istream &in, std::ostream &out) {
    int n, q;
    in >> n >> q;
    vector<vector<int>> adj(n);
    for(int i = 1; i < n; i++){
      int a;
      in >> a;
      a--;
      if(i == 0){
        continue;
      }
      adj[a].push_back(i);
      adj[i].push_back(a);
    }
    vector<int> dum(n);
    vector<vector<int>> up;
    up.resize(n);
    for(int i = 0; i < n; i++){
      up[i].resize(ceil(log2(1.0 * n)) + 1);
    }
    Tree t;
    t.n = n;
    t.l = ceil(log2(1.0 * n));
    t.f = dum;
    t.s = dum;
    t.up = up;
    t.cntr = 0;
    t.adj = adj;
    t.dfs(0,0);
    while(q--){
      int u, v;
      in >> u >> v;
      u--;
      v--;
      int x = t.lca(u,v);
      out << x + 1 << endl;
    }
  }
};


int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
	CompanyQueriesII solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
