/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Maria Chrysafis
 */



#include <iostream>
#include <fstream>
#include <vector>
#include <map>
#include <algorithm>
#include <set>
#include <iomanip>
#include <unordered_map>
#include <unordered_set>
#include <queue>
#include <string>
#include <random>
using namespace std;
int C;
class Problem1WateringTheFields {
public:
    struct DSU {
        vector<int> parent;
        vector<int> compSize;
        int n;
        void fill(){
            parent.resize(n), compSize.resize(n);
            for(int i = 0; i < n; i++){
                parent[i] = i, compSize[i] = 1;
            }
        }
        int find_head(int x){
            if(x == parent[x]){
                return x;
            }
            return find_head(parent[x]);
        }
        void join(int x, int y){
            x = find_head(x);
            y = find_head(y);
            if(x == y){
                return;
            }
            if(compSize[x] > compSize[y]){
                swap(x,y);
                //ensures that compSize[x1] <= compSize[y1]
            }
            parent[x] = y;
            compSize[y] += compSize[x];
        }
        bool comp(int x, int y){
            return (find_head(x) == find_head(y));
        }
    };
    struct Coord {
        int x, y;
        int dist (Coord c) {
            return abs(c.x - x) * abs(c.x - x) + abs(c.y - y) * abs(c.y - y);
        }
    };
    struct Graph {
        vector<Coord> vec;
        int mst (std::istream& in, std::ostream& out) {
            DSU d;
            d.n = vec.size();
            d.fill();
            vector<pair<long long,pair<int,int>>> v;
            for (int i = 0; i < vec.size(); i++) {
                for (int j = i + 1; j < vec.size(); j++) {
                    v.push_back({vec[i].dist(vec[j]), {i, j}});
                }
            }
            sort(v.begin(), v.end());
            int cnt = 0;
            long long tot = 0;
            for (auto p: v) {
                if (p.first < C || d.comp(p.second.first, p.second.second)) {
                    continue;
                }
                d.join(p.second.first, p.second.second);
                tot += p.first;
                cnt++;
            }
            if (cnt != vec.size() - 1) {
                return -1;
            }
            return tot;
        }
    };
	void solve(std::istream& in, std::ostream& out) {
	    freopen("irrigation.in", "r", stdin);
	    freopen("irrigation.out", "w", stdout);
        ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        Graph g;
        int N;
        in >> N >> C;
        g.vec.resize(N);
        for (int i = 0; i < N; i++) {
            in >> g.vec[i].x >> g.vec[i].y;
        }
        out << g.mst(in, out);
	}
};


int main() {
    freopen("irrigation.in", "r", stdin);
    freopen("irrigation.out", "w", stdout);
	Problem1WateringTheFields solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
