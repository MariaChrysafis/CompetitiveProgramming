/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

//Created by Maria Chrysafis
#include <iostream>
#include <fstream>

#include <iostream>
#include <algorithm>
#include <vector>
#include <cmath>
#include <map>
#include <set>
#include <queue>
#include <unordered_map>
#include <unordered_set>
using namespace std;
class Problem3HaybaleFeast {
public:
  vector<long long> pref;
  vector<long long> flavor;
  vector<long long> spicy;
  static pair<int,int> merge(pair<int,int> p1, pair<int,int> p2){
    return make_pair(p1.first,p2.second);
  }
  int cl(int x){
    int pwr = 1;
    while(pwr < x){
      pwr *= 2;
    }
    return pwr;
  }
  struct segmentTree{
    vector<pair<int,int>> vec;
    vector<long long> v;
    vector<long long> arr;
    int INF;
    int N;
    void prelim(){
      vec.resize(2 * N);
      arr.resize(2 * N);
    }
    int build(int ind){
      if(ind >= v.size() - 1){
        arr[ind] = v[ind - (v.size() - 1)];
        return arr[ind];
      }
      arr[ind] = max(build(2 * ind + 1),build(2 * ind + 2));
      return arr[ind];
    }
    pair<int,int> build2(int ind){
      if(ind >= v.size() - 1){
        int x = ind - (v.size() - 1);
        vec[ind] = make_pair(x,x);
        return vec[ind];
      }
      vec[ind] = merge(build2(2 * ind + 1),build2(2 * ind + 2));
      return vec[ind];
    }
    int interval(int i, int L, int R){
      if(vec[i].first > R || vec[i].second < L){
        return INF;
      }
      if(vec[i].first >= L && vec[i].second <= R){
        return arr[i];
      }
      int a = interval(2 * i + 1,L,R);
      int b = interval(2 * i + 2,L,R);
      return max(a,b);
    }
  };
  int binSearch(int L, int R, long long key){
    //binary search for the first element in the range [l,r] of pref that is
    // >= key
    int l = L;
    int r = R;
    while(r > l){
      int m = (l + r)/2;
      if(pref[m] >= key){
        r = m;
      }else{
        l = m + 1;
      }
    }
    if(r < l){
      return -1;
    }
    if(pref[r] >= key){
      return r;
    }
    return -1;
  }
  void solve(std::istream& in, std::ostream& out) {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    int N,M;
    in >> N >> M;
    flavor.resize(N);
    spicy.resize(cl(N));
    for(int i = 0; i < N; i++){
      int a,b;
      in >> a >> b;
      flavor[i] = a;
      spicy[i] = b;
    }
    pref.resize(N);
    pref[0] = flavor[0];
    for(int i = 1; i < N; i++){
      pref[i] = pref[i - 1] + flavor[i];
    }
    reverse(pref.begin(),pref.end());
    pref.push_back(0);
    reverse(pref.begin(),pref.end());
    //initialize and work with the segment tree
    segmentTree segTree;
    segTree.v = spicy;
    segTree.arr = {};
    segTree.vec = {{}};
    segTree.N = cl(spicy.size());
    segTree.prelim();
    segTree.build(0);
    segTree.build2(0);
    segTree.INF = -1;
    int ans = pow(10,9);
    for(int i = 0; i < N; i++){
      int j = binSearch(i,pref.size() - 1,M + pref[i]);
      if(j == -1){
        continue;
      }
      ans = min(ans,segTree.interval(0,i,j));
    }
    out << ans << endl;
  }
};


int main() {
	Problem3HaybaleFeast solver;
	std::ifstream in("hayfeast.in");
	std::ofstream out("hayfeast.out");
	solver.solve(in, out);
	return 0;
}
