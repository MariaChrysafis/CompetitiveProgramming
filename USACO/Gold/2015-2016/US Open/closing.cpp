/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>

#include <iostream>
#include <vector>
#include <set>
#include <algorithm>
using namespace std;
vector<bool> marked;
int cc = 0;
class Problem2ClosingTheFarm {
public:
  struct DSU{
    vector<int> parent;
    vector<int> rank;
    int n;
    void init(){
      parent.resize(n);
      rank.resize(n);
      for(int i = 0; i < n; i++){
        parent[i] = i;
        rank[i] = 0;
      }
    }
    int find_set(int v){
      if(v == parent[v]){
        return v;
      }
      return find_set(parent[v]);
    }
    void unite(int a, int b){
      a = find_set(a);
      b = find_set(b);
      if(a != b){
        if(rank[a] < rank[b]){
          swap(a,b);
        }
        parent[b] = a;
        if(rank[a] == rank[b]){
          rank[a]++;
        }
        cc--;
      }
    }
    int connectedComponents(){
      set<int> s;
      for(int i = 0; i < n; i++){
        if(marked[i]) {
          s.insert(find_set(i));
        }
      }
      return s.size();
    }
  };
  void solve(std::istream &in, std::ostream &out) {
    //firstly, let's build our graph
    int n, m;
    in >> n >> m;
    vector<vector<int>> adj(n);
    for(int i = 0; i < m; i++){
      int u, v;
      in >> u >> v;
      u--;
      v--;
      adj[u].push_back(v);
      adj[v].push_back(u);
    }
    int arr[n];
    for(int i = 0; i < n; i++){
      in >> arr[i];
      arr[i]--;
    }
    DSU dsu;
    dsu.n = n;
    dsu.init();
    marked.resize(n);
    vector<int> ans;
    for(int i = 0; i < n; i++){
      marked[i] = false;
    }
    cc = 1;
    for(int i = n - 1; i >= 0; i--){
      marked[arr[i]] = true;
      for(int j: adj[arr[i]]){
        if(marked[j]){
          dsu.unite(arr[i],j);
        }
      }
      //ans.push_back(dsu.connectedComponents());
      ans.push_back(cc);
      cc++;
    }
    reverse(ans.begin(),ans.end());
    for(int i: ans){
      if(i == 1){
        out << "YES" << '\n';
      }else{
        out << "NO" << '\n';
      }
    }
  }
};


int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
	Problem2ClosingTheFarm solver;
	std::ifstream in("closing.in");
	std::ofstream out("closing.out");
	solver.solve(in, out);
	return 0;
}
