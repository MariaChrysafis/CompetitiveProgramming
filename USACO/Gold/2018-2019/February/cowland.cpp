/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;
vector<int> glob;
vector<int> enjoyment;
int cl(int x){
  int pwr = 1;
  while(pwr < x){
    pwr *= 2;
  }
  return pwr;
}
pair<int,int> merge(pair<int,int> p1, pair<int,int> p2){
  return make_pair(p1.first,p2.second);
}
class Problem1CowLand {
public:
  struct Tree{
    int cntr;
    vector<vector<int>> adj;
    vector<vector<int>> up;
    vector<int> f, s;
    vector<int> sub;
    int n, l;
    void dfsForLCA(int u, int prev){
      f[u] = cntr;
      cntr++;
      up[u][0] = prev;
      for(int i = 1; i <= l; i++){
        up[u][i] = up[up[u][i - 1]][i - 1];
      }
      for(int v: adj[u]){
        if(v != prev){
          dfsForLCA(v, u);
        }
      }
      s[u] = cntr;
      cntr++;
    }
    bool isAncestor(int u, int v){
      return f[u] <= f[v] && s[u] >= s[v];
    }
    int lca(int u, int v){
      if(isAncestor(u,v)){
        return u;
      }
      if(isAncestor(v,u)){
        return v;
      }
      for(int i = l; i >= 0; i--){
        if(!isAncestor(up[u][i],v)){
          u = up[u][i];
        }
      }
      return up[u][0];
    }
    int el(int u, int prev){
      if(adj[u].size() == 1){
        sub[u] = 1;
        return 1;
      }
      sub[u] = 1;
      for(int v: adj[u]){
        if(v != prev){
          sub[u] += el(v,u);
        }
      }
      return sub[u];
    }
  };
  struct segmentTree{
    vector<pair<int,int>> vec;
    vector<int> v;
    vector<int> arr;
    int INF;
    int build(int ind){
      if(ind >= v.size() - 1){
        arr[ind] = v[ind - (v.size() - 1)];
        return arr[ind];
      }
      arr[ind] = build(2 * ind + 1) ^ build(2 * ind + 2);
      return arr[ind];
    }
    pair<int,int> build2(int ind){
      if(ind >= v.size() - 1){
        int x = ind - (v.size() - 1);
        vec[ind] = make_pair(x,x);
        return vec[ind];
      }
      vec[ind] = merge(build2(2 * ind + 1),build2(2 * ind + 2));
      return vec[ind];
    }
    int interval(int i, int L, int R){
      if(vec[i].first > R || vec[i].second < L){
        return INF;
      }
      if(vec[i].first >= L && vec[i].second <= R){
        return arr[i];
      }
      int a = interval(2 * i + 1,L,R);
      int b = interval(2 * i + 2,L,R);
      return a ^ b;
    }
    void update(int k, int u){
      int ind = (v.size() - 1) + k;
      arr[ind] = u;
      while(ind != 0){
        int parent = (ind - 1)/2;
        arr[parent] = arr[parent * 2 + 1] ^ arr[parent * 2 + 2];
        ind = parent;
      }
    }
  };
  void solve(std::istream &in, std::ostream &out) {
    int n, q;
    in >> n >> q;
    enjoyment.resize(n);
    for(int i = 0; i < n; i++){
      in >> enjoyment[i];
    }
    vector<vector<int>> adj(n);
    for(int i = 0; i < n - 1; i++){
      int u, v;
      in >> u >> v;
      u--, v--;
      adj[u].push_back(v);
      adj[v].push_back(u);
    }
    vector<int> dum(n);
    vector<vector<int>> up;
    up.resize(n);
    for(int i = 0; i < n; i++){
      up[i].resize(ceil(log2(1.0 * n)) + 1);
    }
    Tree t;
    t.n = n, t.l = ceil(log2(1.0 * n));
    t.f = dum, t.s = dum, t.sub = dum, t.up = up;
    t.cntr = 0, t.adj = adj;
    t.dfsForLCA(0, 0);
    t.el(0,-1);
    int newN = cl(2 * n);
    vector<pair<int,int>> vec(2 * newN);
    vector<int> arr1(2 * newN);
    glob.resize(newN);
    for(int i = 0; i < n; i++){
      int f = t.f[i];
      int s = t.s[i];
      glob[f] = glob[s] = i;
    }
    vector<int> v(newN);
    for(int i = 0; i < 2 * n; i++){
      v[i] = enjoyment[glob[i]];
      //out << v[i] << " ";
    }
    //initialize the segment tree
    segmentTree segTree;
    segTree.INF = 0;
    segTree.v = v;
    segTree.vec = vec;
    segTree.arr = arr1;
    segTree.build(0);
    segTree.build2(0);
    while(q--){
      int d;
      in >> d;
      if(d == 2){
        int a, b;
        in >> a >> b;
        a--;
        b--;
        int x1 = segTree.interval(0,0,t.f[a]);
        int x2 = segTree.interval(0,0,t.f[b]);
        int x3 = enjoyment[t.lca(a,b)];
        out << (x1 ^ (x2 ^ x3)) << endl;
      }else{
        //update the segmentTree
        int a, b;
        in >> a >> b;
        a--;
        segTree.update(t.f[a],b);
        segTree.update(t.s[a],b);
        enjoyment[a] = b;
      }
    }
  }
};
int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
	Problem1CowLand solver;
	std::ifstream in("cowland.in");
	std::ofstream out("cowland.out");
	solver.solve(in, out);
	return 0;
}
