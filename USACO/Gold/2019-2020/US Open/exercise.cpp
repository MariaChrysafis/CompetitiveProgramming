/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

//Created by Maria Chrysafis
#include <iostream>
#include <fstream>

#include <iostream>
#include <algorithm>
#include <vector>
#include <map>
#include <set>
#include <queue>
#include <unordered_map>
#include <unordered_set>
#include <cmath>
using namespace std;
class Problem3Exercise {
public:
  vector<long long> sieve(int n){
    bool prime[n + 1];
    for(int i = 0; i <= n; i++){
      prime[i] = true;
    }
    for (int p = 2; p * p <= n; p++){
      if (prime[p]){
        for (int i = p * p; i <= n; i += p){
          prime[i] = false;
        }
      }
    }
    vector<long long> ans;
    for (int p = 2; p <= n; p++) {
      if (prime[p]) {
        ans.push_back(p);
      }
    }
    return ans;
  }
  void solve(std::istream& in, std::ostream& out) {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    long long N, MOD;
    in >> N >> MOD;
    long long MAX = 10001;
    vector<long long> v = sieve(MAX);
    reverse(v.begin(),v.end());
    v.push_back(0);
    reverse(v.begin(),v.end());
    long long DP[v.size()][N + 1];
    for(int i = 0; i <= N; i++){
      DP[0][i] = 1;
    }
    long long BMOD = MOD * sqrt(MOD);
    for(int i = 1; i < v.size(); i++){
      for(int j = 0; j <= N; j++){
        DP[i][j] = DP[i - 1][j];
        long long pwr = v[i];
        while(pwr <= j){
          DP[i][j] += (DP[i - 1][j - pwr] * pwr) % MOD;
          pwr *= v[i];
        }
        if(DP[i][j] > MOD){
          DP[i][j] -= MOD;
        }
      }
    }
    out << DP[v.size() - 1][N];
  }
};

int main() {
	Problem3Exercise solver;
	//std::istream& in(std::cin);
	//std::ostream& out(std::cout);
  ifstream in("exercise.in");
  ofstream out("exercise.out");
	solver.solve(in, out);
	return 0;
}
