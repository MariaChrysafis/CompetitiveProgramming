/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>

/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>
#include <ext/pb_ds/assoc_container.hpp>

#include <map>
#include <vector>
using namespace __gnu_pbds;
using namespace std;
typedef tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
class Problem1WhyDidTheCowCrossTheRoad {
public:
  long long inv(vector<int> v){
    ordered_set s;
    long long cntr = 0;
    for(int i = v.size() - 1; i >= 0; i--){
      int x = s.order_of_key(v[i]);
      cntr += x;
      s.insert(v[i]);
    }
    return cntr;
  }
  long long f(vector<int> a, vector<int> b){
    int n = a.size();
    int ma[n];
    int mb[n];
    for(int i = 0; i < n; i++){
      a[i]--;
      ma[a[i]] = i;
      b[i]--;
      mb[b[i]] = i;
    }
    vector<int> v(n);
    for(int i = 0; i < n; i++){
      v[i] = mb[a[i]] - i;
    }
    for(int i = 0; i < n; i++){
      v[i] += i;
    }
    long long inversions = inv(v);
    long long ans = inversions;
    for(int i = 0; i < n; i++){
      inversions += -2 * v[i] + n - 1;
      ans = min(ans,inversions);
    }
    return ans;
  }
  void solve(std::istream &in, std::ostream &out) {
    int n;
    in >> n;
    vector<int> a(n);
    vector<int> b(n);
    for(int i = 0; i < n; i++){
      in >> a[i];
    }
    for(int i = 0; i < n; i++){
      in >> b[i];
    }
    long long x = f(a,b);
    long long y = f(b,a);
    out << min(x,y) << endl;
  }
};


int main() {
  ios_base::sync_with_stdio(false);
        cin.tie(NULL);
	Problem1WhyDidTheCowCrossTheRoad solver;
        std::ifstream in("mincross.in");
	std::ofstream out("mincross.out");
	solver.solve(in, out);
	return 0;
}
