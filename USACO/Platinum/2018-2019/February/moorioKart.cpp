/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>

#include <iostream>
#include <map>
#include <vector>
#include <queue>
using namespace std;
class Problem2MoorioKart {
public:
  long long N, M, X, Y;
  long long MOD = 1000000007;
  vector<vector<pair<long long,long long>>> adj;
  vector<long long> connectComponent;
  vector<vector<long long>> forest;
  vector<vector<long long>> path;
  void dfs(long long cc, long long node1, long long prevNode){
    connectComponent[node1] = cc;
    for(pair<long long,long long> p: adj[node1]){
      if(p.first == prevNode){
        continue;
      }
      dfs(cc,p.first,node1);
    }
  }
  long long pwr(long long a, long long b){
    long long cur = 1;
    for(long long i = 0; i < b; i++){
      cur *= a;
      cur %= MOD;
    }
    return cur;
  }
  long long fact(long long a){
    long long ans = 1;
    for(long long i = 1; i <= a; i++){
      ans *= i;
      ans %= MOD;
    }
    return ans;
  }
  vector<long long> bfs(vector<long long> v, long long strt){
    map<long long,bool> hasVisited;
    queue<pair<long long,long long>> q;
    map<long long,long long> ans;
    q.push({strt,0});
    while(!q.empty()){
      long long no = q.front().first;
      long long we = q.front().second;
      hasVisited[no] = true;
      ans[no] = (we);
      q.pop();
      for(pair<long long,long long> p: adj[no]){
        if(hasVisited[p.first]) continue;
        q.push({p.first, p.second + we});
      }
    }
    vector<long long> vec;
    for(long long i: v){
      vec.push_back(ans[i]);
    }
    return vec;
  }
  void solve(std::istream &in, std::ostream &out) {
    in >> N >> M >> X >> Y;
    adj.resize(N);
    for(long long i = 0; i < M; i++){
      long long a,b,c;
      in >> a >> b >> c;
      a--;
      b--;
      adj[a].push_back({b,c});
      adj[b].push_back({a,c});
    }
    long long cc = 0;
    connectComponent.resize(N);
    for(long long i = 0; i < N; i++){
      connectComponent[i] = -1;
    }
    for(long long i = 0; i < N; i++){
      if(connectComponent[i] == -1){
        dfs(cc,i,-1);
        cc++;
      }
    }
    forest.resize(cc);
    for(long long i = 0; i < N; i++){
      forest[connectComponent[i]].push_back(i);
    }
    //vector<long long> ans = bfs({3,4},4);
    vector<long long> path_sum;
    path.resize(cc);
    path_sum.resize(cc);
    for(long long i = 0; i < cc; i++){
      vector<vector<long long>> grid;
      for(long long j: forest[i]){
        vector<long long> ans = bfs(forest[i],j);
        grid.push_back(ans);
      }
      //flatten out the grid
      for(long long j = 0; j < grid.size(); j++){
        for(long long k = 0; k < j; k++){
          path[i].push_back(grid[j][k]);
        }
      }
    }
    for(long long i = 0; i < cc; i++){
      path_sum[i] = 0;
      for(long long j: path[i]){
        path_sum[i] += j;
        path_sum[i] %= MOD;
      }
    }
    map<long long,long long> oc;
    long long ans = 0;
    long long prod = 1;
    for(long long i = 0; i < cc; i++){
      long long cntr = 1;
      prod = 1;
      for(long long j = 0; j < cc; j++){
        prod *= path[j].size();
        if(i == j) continue;
        cntr *= path[j].size();
        prod %= MOD;
        cntr %= MOD;
      }
      ans += (cntr * path_sum[i]) % MOD;
      ans %= MOD;
    }
    long long DP[Y][cc];
    for(long long i = 0; i < Y; i++){
      for(long long j = 0; j < cc; j++){
        DP[i][j] = 0;
      }
    }
    for(long long i: path[0]){
      if(i < Y){
        DP[i][0]++;
      }
    }
    for(long long i = 1; i < cc; i++){
      for(long long j = 0; j < Y; j++){
        for(long long k: path[i]){
          if(j + k >= Y) continue;
          DP[j + k][i] += DP[j][i - 1];
          DP[j + k][i] %= MOD;
        }
      }
    }
    long long extra = 0;
    for(long long i = 0; i < Y - cc * X; i++){
      extra += ((X * cc + i) % MOD * (DP[i][cc - 1])) % MOD;
      extra %= MOD;
    }
    ans += (((X * prod) % MOD * cc) % MOD - extra + MOD) % MOD;
    ans %= MOD;
    long long l1 = (ans * pwr(2,cc - 1)) % MOD;
    long long l2 = fact(cc - 1);
    out << (l1 * l2) % MOD << endl;
  }
};

int main() {
  Problem2MoorioKart solver;
  std::ifstream in("mooriokart.in");
      std::ofstream out("mooriokart.out");
      solver.solve(in, out);
      return 0;
}
