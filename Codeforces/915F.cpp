/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Maria Chrysafis (Olympia)
 */



#include <iostream>
#include <fstream>
#include <vector>
#include <map>
#include <set>
#include <iomanip>
#include <algorithm>
#include <unordered_map>
#include <unordered_set>
#include <queue>
#include <string>
#include <random>
using namespace std;
long long answer = 0;
class FImbalanceValueOfATree {
public:
    struct dsu{
        vector<int> parent;
        vector<long long> compSize;
        int n;
        void fill(int N){
            n = N;
            parent.resize(n), compSize.resize(n);
            for(int i = 0; i < n; i++){
                parent[i] = -1, compSize[i] = 1;
            }
        }
        int find_head(int x){
            if(-1 == parent[x]){
                return x;
            }
            return find_head(parent[x]);
        }
        void join(int x, int y, long long val){
            x = find_head(x);
            y = find_head(y);
            if(x == y){
                return;
            }
            if(compSize[x] > compSize[y]){
                swap(x,y);
            }
            parent[x] = y;
            answer += compSize[x] * compSize[y] * val;
            compSize[y] += compSize[x];
        }
        bool comp(int x, int y){
            return (find_head(x) == find_head(y));
        }
    };
    void solver (vector<long long> v, vector<vector<int>> adj) {
        map<long long, vector<int>> myMap;
        for (int i = 0; i < v.size(); i++) {
            myMap[v[i]].push_back(i);
        }
        dsu d;
        d.fill(adj.size());
        for (auto& p: myMap) {
            for (int j: p.second) {
                for (int k: adj[j]) {
                    if (v[k] <= p.first) {
                        d.join(k, j, p.first);
                    }
                }
            }
        }
    }
    void solve(std::istream& in, std::ostream& out) {
        ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        long long N;
        in >> N;
        vector<long long> v(N);
        for (int i = 0; i < N; i++) {
            in >> v[i];
        }
        vector<vector<int>> adj(N);
        for (int i = 0; i < N - 1; i++) {
            int u1, v1;
            in >> u1 >> v1;
            u1--, v1--;
            adj[u1].push_back(v1), adj[v1].push_back(u1);
        }
        solver(v, adj);
        for (int i = 0; i < v.size(); i++) {
            v[i] -= 2 * v[i];
        }
        solver(v, adj);
        out << answer;
    }
};


int main() {
	FImbalanceValueOfATree solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
