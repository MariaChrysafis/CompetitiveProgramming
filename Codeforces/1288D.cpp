/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <algorithm>
#include <fstream>

#include <iostream>
#include <vector>
#include <set>
#include <cmath>
#pragma GCC target ("avx2")
#pragma GCC optimization ("O3")
#pragma GCC optimization ("unroll-loops")
#pragma optimization_level 3
#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math,O3")
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native")
using namespace std;
class DMinimaxProblem {
public:
  struct Pair{
    int first, second;
    bool operator<(const Pair& p) const{
      return (this->first < p.first);
    }
    bool operator==(const Pair &p) const{
      return (this->first == p.first);
    }
  };
  int n, m;
  vector<vector<int>> arr;
  int pwr[9];
  int convert(vector<int> v, int x){
    int ans = 0;
    for(int i = 0; i < v.size(); i++){
      if(v[i] >= x){
        ans += pwr[i];
      }
    }
    return ans;
  }
  pair<bool,pair<int,int>> valid(int x){
    set<struct Pair> s;
    for(int i = 0; i < n; i++){
      s.insert({convert(arr[i], x), i});
    }
    vector<Pair> ans;
    for(auto it = s.begin(); it != s.end(); it++){
      ans.push_back(*it);
    }
    int powr = pwr[m] - 1;
    for(int i = 0; i < ans.size(); i++){
      for(int j = i; j < ans.size(); j++){
        int OR = ans[i].first | ans[j].first;
        if(OR == powr) return {true,{ans[i].second,ans[j].second}};
      }
    }
    return {false,{-1,-1}};
  }
  int binSearch(int l, int r){
    //cout << l << " " << r << endl;
    int m = l + (r - l)/2;
    if(l == r){
      return l;
    }
    if(valid(m).first){
      return binSearch(m + 1, r);
    }else{
      return binSearch(l, m);
    }
  }
  void solve(std::istream& in, std::ostream& out) {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    pwr[0] = 1, pwr[1] = 2, pwr[2] = 4, pwr[3] = 8, pwr[4] = 16, pwr[5] = 32;
    pwr[6] = 64, pwr[7] = 128, pwr[8] = 256;
    //int n, m;
    in >> n >> m;
    arr.resize(n);
    for(int i = 0; i < n; i++){
      arr[i].resize(m);
      for(int j = 0; j < m; j++){
        in >> arr[i][j];
      }
    }
    auto x = binSearch(0, 1000000001) - 1;
    //out <<x  << endl;
    out << valid(x).second.first + 1<< " " << valid(x).second.second + 1
        <<endl;
    //return;
    //out <<x  << endl;
    //out << valid(x).second.first << " " << valid(x).second.second << endl;
  }
};

int main() {
	DMinimaxProblem solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
