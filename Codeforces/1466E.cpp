/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */
 
#include <iostream>
#include <fstream>
 
#include <iostream>
#include <fstream>
#include <cmath>
 
 
#include <vector>
using namespace std;
class EApolloVersusPan {
public:
  static const int64_t MOD = 1000000007;
  static const int64_t sMOD = 31622;
  static const int64_t MOD1 = MOD * sMOD;
  vector<int64_t> pwr;
  int64_t n;
  void f(std::istream &in, std::ostream &out) {
 
    in >> n;
    int64_t arr[n];
    for (int i = 0; i < n; i++) {
      in >> arr[i];
    }
    int sm[64];
    for (int i = 0; i < 64; i++) {
      int64_t sum = 0;
      for (int j = 0; j < n; j++) {
        sum += (arr[j] & (1ll << (i))) ? 1 : 0;
      }
      sm[i] = (sum * pwr[i]) % MOD;
    }
    int64_t x = 0;
    for (int i = 0; i < n; i++) {
      int64_t l = 0;
      int64_t r = 0;
      for (int64_t j = 0; j < 62; j++) {
        if ((arr[i] & (1ll << (j)))) {
          l += uint64_t(n) * pwr[j];
          r += sm[j];
        }
        else {
          l += sm[j];
        }
      }
      if(l >= MOD){
        l %= MOD;
      }
      if(r >= MOD){
        r %= MOD;
      }
      x += l * r;
      x %= MOD;
    }
    x %= MOD;
    out << x << endl;
  }
  void solve(std::istream &in, std::ostream &out) {
    ios_base::sync_with_stdio(false), cin.tie(nullptr);
    int64_t t;
    in >> t;
    pwr.resize(64);
    pwr[0] = 1;
    for (int i = 1; i < 64; i++) {
      pwr[i] = pwr[i - 1] * 2;
      pwr[i] %= MOD;
    }
    while (t--) {
      f(in, out);
    }
  }
};
 
int main() {
	EApolloVersusPan solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
