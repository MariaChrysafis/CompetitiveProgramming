/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <algorithm>
#include <fstream>

#include <iostream>
#include <algorithm>
#include <fstream>



#include <vector>
#include <cmath>
#pragma GCC target ("avx2")
#pragma GCC optimization ("O3")
#pragma GCC optimization ("unroll-loops")
#pragma optimization_level 3
#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math,O3")
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native")
using namespace std;
class FTriangularPaths {
public:
  int dist(int x1, int y1, int x2, int y2){
    if((x1 + y1) % 2 == 0 && x2 - x1 == y2 - y1){
      return abs(x1 - x2);
    }
    if((x1 + y1) % 2 == 0){
      return dist(x1 + 1, y1, x2, y2);
    }
    return ceil(1.0 * abs(abs(x2 - x1) - abs(y2 - y1))/2.0);
  }
  void f(std::istream& in, std::ostream& out) {
    int n;
    in >> n;
    vector<pair<int,int>> arr;
    int l[n];
    int r[n];
    for(int i = 0; i < n; i++){
      in >> l[i];
    }
    for(int i = 0; i < n; i++){
      in >> r[i];
    }
    for(int i = 0; i < n; i++){
      arr.push_back({l[i], r[i]});
    }
    arr.push_back({1,1});
    sort(arr.begin(), arr.end());
    //out << dist(2,1,3,2) << endl;
    int d = 0;
    for(int i = 0; i < n; i++){
      int x1 = arr[i].first;
      int y1 = arr[i].second;
      int x2 = arr[i + 1].first;
      int y2 = arr[i + 1].second;
      //out << x1 << " " << y1 << " " << x2 << " " << y2 << endl;
      d += dist(x1, y1, x2, y2);
      //out << dist(x1, y1, x2, y2) << endl;
    }
    out << d << endl;
  }
  void solve(std::istream& in, std::ostream& out) {
    int t;
    in >> t;
    while(t--){
      f(in, out);
    }
  }
};


int main() {
	FTriangularPaths solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
