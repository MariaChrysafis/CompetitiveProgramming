/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Maria Chrysafis (Olympia)
 */



#include <iostream>
#include <fstream>
#include <vector>
#include <map>
#include <set>
#include <iomanip>
#include <algorithm>
#include <unordered_map>
#include <unordered_set>
#include <queue>
#include <string>
#include <random>
using namespace std;
bool comp (pair<int,int> p1, pair<int,int> p2) {
    if (p1.second - p1.first == p2.second - p2.first) {
        //prefer intervals that are smaller
        return (p1.first < p2.first);
    }
    return (p1.second - p1.first < p2.second - p2.first); //prefer shorter intervals
}
class CDeletionOfRepeats {
public:
    const int MOD = 1e9 + 7;
    const int MOD1 = 1e9 + 9;
    long long binPow (long long x, long long y, int modulus) {
        long long ans = 1;
        long long res = x;
        while (y > 0) {
            if (y & 1) {
                ans *= res;
                ans %= modulus;
            }
            res *= res;
            res %= modulus;
            y /= 2;
        }
        return ans;
    }
    vector<long long> pref = {0};
    vector<long long> pref1 = {0};
    long long interval (int l, int r) {
        return (pref[r + 1] - (pref[l] * binPow(999994379ll, r - l + 1, MOD)) % MOD + MOD) % MOD;
    }
    long long interval1 (int l, int r) {
        return (pref1[r + 1] - (pref1[l] * binPow(999991469ll, r - l + 1, MOD1)) % MOD1 + MOD1) % MOD1;
    }
	void solve(std::istream& in, std::ostream& out) {
        ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        int n;
        in >> n;
        vector<long long> v(n);
        map<int, vector<int>> myMap;
        for (int i = 0; i < n; i++) {
            in >> v[i];
            myMap[v[i]].push_back(i);
            pref.push_back((pref.back() * 999994379ll + v[i]) % MOD);
            pref1.push_back((pref1.back() * 999991469ll + v[i]) % MOD1);
        }
        vector<pair<int,int>> intervals;
        for (auto p: myMap) {
            vector<int> vec = p.second;
            for (int i = 0; i < vec.size(); i++) {
                for (int j = i + 1; j < vec.size(); j++) {
                    if (2 * vec[j] - vec[i] - 1 < 0 || 2 * vec[j] - vec[i] - 1 >= n) {
                        continue;
                    }
                    long long left = interval(vec[i], vec[j] - 1);
                    long long right = interval(vec[j], 2 * vec[j] - vec[i] - 1);
                    long long l1 = interval1(vec[i], vec[j] - 1);
                    long long r1 = interval1(vec[j], 2 * vec[j] - vec[i] - 1);
                    if (left == right && l1 == r1) {
                        intervals.emplace_back(vec[i], 2 * vec[j] - vec[i] - 1);
                    }
                }
            }
        }
        sort(intervals.begin(), intervals.end(), comp);
        int lastTaken = -1;
        for (auto& p: intervals) {
            //out << p.first << " " << p.second << '\n';
            int m = (p.first + p.second)/2;
            if (p.first <= lastTaken) {
                continue;
            }
            lastTaken = m;
        }
        out << n - lastTaken - 1 << '\n';
        for (int i = lastTaken + 1; i < n; i++) {
            out << v[i] << ' ';
        }
	}
};

int main() {
	CDeletionOfRepeats solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
