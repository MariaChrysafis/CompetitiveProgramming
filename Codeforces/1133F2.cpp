/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Maria Chrysafis (Olympia)
 */



#include <iostream>
#include <fstream>
#include <vector>
#include <map>
#include <set>
#include <iomanip>
#include <algorithm>
#include <unordered_map>
#include <unordered_set>
#include <queue>
#include <string>
#include <random>
using namespace std;
class F2SpanningTreeWithOneFixedDegree {
public:
    struct dsu{
        vector<int> parent;
        vector<int> compSize;
        int n;
        void fill(){
            parent.resize(n), compSize.resize(n);
            for(int i = 0; i < n; i++){
                parent[i] = i, compSize[i] = 1;
            }
        }
        int find_head(int x){
            if(x == parent[x]){
                return x;
            }
            return find_head(parent[x]);
        }
        void join(int x, int y){
            x = find_head(x);
            y = find_head(y);
            if(x == y){
                return;
            }
            if(compSize[x] > compSize[y]){
                swap(x,y);
                //ensures that compSize[x1] <= compSize[y1]
            }
            parent[x] = y;
            compSize[y] += compSize[x];
        }
        bool comp(int x, int y){
            return (find_head(x) == find_head(y));
        }
    };
    struct Graph {
        vector<vector<int>> adj;
        vector<pair<int,int>> read(int D) {
            dsu d;
            d.n = adj.size();
            d.fill();
            vector<pair<int,int>> edges;
            for (int i = 0; i < adj.size(); i++) {
                for (int j: adj[i]) {
                    if (i == 0 || j == 0) {
                        continue;
                    }
                    if (d.find_head(j) != d.find_head(i)) {
                        d.join(i, j);
                    }
                }
            }
            for (int i: adj[0]) {
                if (d.find_head(i) != d.find_head(0)) {
                    d.join(i, 0);
                    edges.emplace_back(0, i);
                }
            }
            d.fill();
            for (auto& p: edges) {
                d.join(p.first, p.second);
                //cout << p.first << " " << p.second << endl;
            }
            for (int i: adj[0]) {
                if (edges.size() == D) {
                    break;
                }
                //cout << i << " " << 0 << endl;
                if (d.find_head(i) != d.find_head(0)) {
                    d.join(i, 0);
                    edges.emplace_back(i, 0);
                }
            }
            if (edges.size() != D) {
                return {};
            }
            for (int i = 0; i < adj.size(); i++) {
                for (int j: adj[i]) {
                    if (i == 0 || j == 0) continue;
                    if (d.find_head(i) != d.find_head(j)) {
                        d.join(i, j);
                        edges.emplace_back(i, j);
                    }
                }
            }
            return edges;
        }
    };
	void solve(std::istream& in, std::ostream& out) {
        ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        Graph g;
        int n, m, d;
        in >> n >> m >> d;
        g.adj.resize(n);
        for (int i = 0; i < m; i++) {
            int u, v;
            in >> u >> v;
            u--, v--;
            g.adj[u].push_back(v), g.adj[v].push_back(u);
        }
        vector<pair<int,int>> vec = g.read(d);
        if (vec.empty()) {
            out << "NO\n";
            return;
        } else {
            out << "YES\n";
        }
        for (auto p: vec) {
            out << p.first + 1 << " " << p.second + 1 << '\n';
        }
	}
};


int main() {
	F2SpanningTreeWithOneFixedDegree solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
