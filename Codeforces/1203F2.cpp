/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Maria Chrysafis (Olympia)
 */



#include <iostream>
#include <fstream>
#include <cassert>
#include <vector>
#include <map>
#include <set>
#include <iomanip>
#include <algorithm>
#include <unordered_map>
#include <unordered_set>
#include <queue>
#include <string>
#include <random>
using namespace std;
struct Project {
    int requisite_rating;
    int rating_delta;
};
bool comp_by_requisite_rating (Project p1, Project p2) {
    return (p1.requisite_rating < p2.requisite_rating);
}
bool comp (Project p1, Project p2) {
    return (p1.rating_delta + p1.requisite_rating < p2.rating_delta + p2.requisite_rating);
}
const int INF = 1e6;
class F2CompleteTheProjectsHardVersion {
public:
	void solve(std::istream& in, std::ostream& out) {
        ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        int n, r;
        in >> n >> r;
        vector<Project> projects(n);
        for (int i = 0; i < n; i++) {
            in >> projects[i].requisite_rating >> projects[i].rating_delta;
        }
        sort (projects.begin(), projects.end(), comp_by_requisite_rating);
        vector<Project> new_projects;
        int sz = 0;
        for (int i = 0; i < n; i++) {
            if (projects[i].rating_delta >= 0) {
                //always pursue it
                if (r >= projects[i].requisite_rating) {
                    //if current rating exceeds needed rating
                    sz++;
                    r += projects[i].rating_delta;
                }
            } else {
                new_projects.push_back(projects[i]);
            }
        }
        //out << r << '\n';
        swap(new_projects, projects);
        sort(projects.begin(), projects.end(), comp);
        reverse(projects.begin(), projects.end());
        n = projects.size();
        int dp[n + 1][r + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= r; j++) {
                //we have rating j and we have considered i projects
                if (i == 0) {
                    dp[i][j] = -10000;
                    if (j == r) {
                        dp[i][j] = 0;
                    }
                    continue;
                }
                dp[i][j] = dp[i - 1][j];
                int prev_rating = j - projects[i - 1].rating_delta;
                if (prev_rating <= r && prev_rating >= projects[i - 1].requisite_rating) {
                    dp[i][j] = max(dp[i - 1][prev_rating] + 1, dp[i][j]);
                }
            }
        }
        int myMax = 0;
        for (int i = r; i >= 0; i--) {
            myMax = max(myMax, dp[n][i]);
        }
        out << myMax + sz;
	}
};


int main() {
	F2CompleteTheProjectsHardVersion solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
