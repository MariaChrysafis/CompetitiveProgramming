/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */
 
#include <iostream>
#include <fstream>
#include <string>
#include <cstring>
#include <iostream>
#pragma GCC target("avx2")
#pragma GCC optimization("O3")
#pragma GCC optimization("unroll-loops")
#pragma optimization_level 3
#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math,O3")
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native")
using namespace std;
class CDoubleEndedStrings {
public:
  //copied from outside source
  string LCS(string X, string Y, int m, int n)
  {
    int maxlen = 0;         // stores the max length of LCS
    int endingIndex = m;    // stores the ending index of LCS in `X`
 
    // `lookup[i][j]` stores the length of LCS of substring
    // `X[0…i-1]`, `Y[0…j-1]`
    int lookup[m + 1][n + 1];
 
    // initialize all cells of the lookup table to 0
    memset(lookup, 0, sizeof(lookup));
 
    // fill the lookup table in a bottom-up manner
    for (int i = 1; i <= m; i++)
    {
      for (int j = 1; j <= n; j++)
      {
        // if the current character of `X` and `Y` matches
        if (X[i - 1] == Y[j - 1])
        {
          lookup[i][j] = lookup[i - 1][j - 1] + 1;
 
          // update the maximum length and ending index
          if (lookup[i][j] > maxlen)
          {
            maxlen = lookup[i][j];
            endingIndex = i;
          }
        }
      }
    }
 
    // return longest common substring having length `maxlen`
    return X.substr(endingIndex - maxlen, maxlen);
  }
 
  void f(std::istream &in, std::ostream &out) {
    string s1, s2;
    in >> s1 >> s2;
    int x = (s1.length() +  s2.length());
    out << x - 2 * LCS(s1, s2, s1.length(), s2.length()).length() << endl;
  }
  void solve(std::istream &in, std::ostream &out) {
    int t;
    in >> t;
    while(t--){
      f(in, out);
    }
  }
};
 
 
int main() {
	CDoubleEndedStrings solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
