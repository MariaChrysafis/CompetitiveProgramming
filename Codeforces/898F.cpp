/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Maria Chrysafis (Olympia)
 */



#include <iostream>
#include <fstream>
#include <vector>
#include <map>
#include <set>
#include <iomanip>
#include <algorithm>
#include <unordered_map>
#include <unordered_set>
#include <queue>
#include <string>
#include <random>
using namespace std;
vector<long long> pref = {0};
vector<long long> pref1 = {0};
vector<long long> powr = {1};
vector<long long> powr1 = {1};
class FRestoringTheExpression {
public:
    const int MOD = 1e9 + 9;
    const int MOD1 = 1e9 + 27;
    long long mult (long long x, long long y) {
        return (x * y) % MOD;
    }
    long long mult1 (long long x, long long y) {
        return (x * y) % MOD1;
    }
    long long interval (int x, int y) {
        long long len = y - x + 1;
        return (pref[y + 1] - (pref[x] * powr[len]) % MOD + 2 * MOD) % MOD;
    }
    long long interval1 (int x, int y) {
        long long len = y - x + 1;
        return (pref1[y + 1] - (pref1[x] * powr1[len]) % MOD1 + 2 * MOD1) % MOD1;
    }
    void solve(std::istream& in, std::ostream& out) {
        ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        string s;
        in >> s;
        for (int i = 0; i < s.length(); i++) {
            pref.push_back(pref.back() * 10 + (s[i] - '0'));
            pref1.push_back(pref1.back() * 10 + (s[i] - '0'));
            pref.back() %= MOD;
            pref1.back() %= MOD1;
            powr.push_back(powr.back() * 10);
            powr.back() %= MOD;
            powr1.push_back(powr1.back() * 10);
            powr1.back() %= MOD1;
        }
        for (int i = 0; i < s.length(); i++) {
            vector<int> pos;
            pos.push_back((s.length() - 2 + i)/2);
            pos.push_back((s.length() - 1 + i)/2);
            pos.push_back((s.length() + i)/2);
            pos.push_back((s.length() + 1 + i)/2);
            pos.push_back(s.length() - 3 - i);
            pos.push_back(s.length() - 2 - i);
            pos.push_back(s.length() - 1 - i);
            for (int j: pos) {
                if (!(j >= i + 1 && j + 1 <= s.length() - 1)) {
                    continue;
                }
                if (s[0] == '0' && i != 0) {
                    continue;
                }
                if (s[i + 1] == '0' && j != i + 1) {
                    continue;
                }
                if (s[j + 1] == '0' && s.length() - 1 != j + 1) {
                    continue;
                }
                long long left = interval(0, i);
                long long mid = interval(i + 1, j);
                long long right = interval(j + 1, s.length() - 1);
                long long left1 = interval1(0, i);
                long long mid1 = interval1(i + 1, j);
                long long right1 = interval1(j + 1, s.length() - 1);
                if ((left + mid) % MOD == right && (left1 + mid1) % MOD1 == right1) {
                    for (int k = 0; k <= i; k++) {
                        out << s[k];
                    }
                    out << "+";
                    for (int k = i + 1; k <= j; k++) {
                        out << s[k];
                    }
                    out << "=";
                    for (int k = j + 1; k <= s.length() - 1; k++) {
                        out << s[k];
                    }
                    return;
                }
            }
        }
    }
};


int main() {
    FRestoringTheExpression solver;
    std::istream& in(std::cin);
    std::ostream& out(std::cout);
    solver.solve(in, out);
    return 0;
}
