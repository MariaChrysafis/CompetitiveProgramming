/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Maria Chrysafis (Olympia)
 */



#include <iostream>
#include <fstream>
#include <vector>
#include <map>
#include <set>
#include <iomanip>
#include <algorithm>
#include <cassert>
#include <unordered_map>
#include <unordered_set>
#include <queue>
#include <string>
#include <random>
#pragma GCC optimize("O1")
#pragma GCC optimize("Ofast")
using namespace std;

const int MOD = 1e9 + 7;

struct Matrix {
    long long arr[2][2];

    Matrix operator*(Matrix m1) {
        Matrix ans;
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                ans.arr[i][j] = 0;
                for (int k = 0; k < 2; k++) {
                    ans.arr[i][j] += (arr[i][k] * m1.arr[k][j]) % MOD;
                }
                ans.arr[i][j] %= MOD;
            }
        }
        return ans;
    }

    Matrix operator + (Matrix m1) {
        Matrix ans;
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                ans.arr[i][j] = arr[i][j] + m1.arr[i][j];
                if (ans.arr[i][j] >= MOD) {
                    ans.arr[i][j] -= MOD;
                }
            }
        }
        return ans;
    }
};

Matrix powr(Matrix m, long long powr) {
    Matrix ans = {{{1, 0}, {0, 1}}};
    Matrix res = m;
    while (powr > 0) {
        if (powr & 1) {
            ans = ans * res;
        }
        res = res * res;
        powr /= 2;
    }
    return ans;
}

vector<Matrix> vec;
vector<long long> addLater;
Matrix fib = {{{0, 1}, {1, 1}}};

void push(long long v) {
    addLater[2 * v + 1] += addLater[v];
    vec[2 * v + 1] = vec[2 * v + 1] * powr(fib, addLater[v]);
    addLater[2 * v] += addLater[v];
    vec[2 * v] = vec[2 * v] * powr(fib, addLater[v]);
    addLater[v] = 0;
}

void upd(int dum, long long tl, int tr, int l, int r, long long val) {
    if (tr < l || tl > r) {
        return;
    }
    if (tl >= l && tr <= r) {
        addLater[dum] += val;
        vec[dum] = vec[dum] * powr(fib, val);
        return;
    }
    push(dum);
    int mid = (tl + tr) >> 1;
    upd(2 * dum, tl, mid, l, r, val);
    upd(2 * dum + 1, mid + 1, tr, l, r, val);
    vec[dum] = vec[2 * dum] + vec[2 * dum + 1];
}

void upd(int l, int r, long long val) {
    upd(1, 0, (int) vec.size() / 2 - 1, l, r, val);
}

Matrix get(int dum, int tl, int tr, int &l, int &r) {
    if (tl > r || tr < l) {
        return {{{0, 0}, {0, 0}}};
    }
    if (tl >= l && tr <= r) {
        return vec[dum];
    }
    push(dum);
    int tm = (tl + tr) >> 1;
    return get(dum * 2, tl, tm, l, r) + get(dum * 2 + 1, tm + 1, tr, l, r);
}

Matrix get(int l, int r) {
    return get(1, 0, (int) vec.size() / 2 - 1, l, r);
}

void resz(long long n) {
    long long sz = ((1 << (long long) ceil(log2(n))));
    vec.assign(sz * 2, {{{1, 0}, {0, 1}}});
    addLater.assign(sz * 2, 0);
}

class CSashaAndArray {
public:
    void solve(std::istream &in, std::ostream &out) {
        ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        int n;
        in >> n;
        int m;
        in >> m;
        resz(n);
        for (int i = 0; i < n; i++) {
            int x;
            in >> x;
            upd(i, i, x);
        }
        while (m--) {
            int t;
            in >> t;
            if (t == 2) {
                int u, v;
                in >> u >> v;
                u--, v--;
                out << get(u, v).arr[0][1] << '\n';
            } else {
                int l, r, x;
                in >> l >> r >> x;
                l--, r--;
                upd(l, r, x);
            }
        }
    }
};


int main() {
	CSashaAndArray solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
