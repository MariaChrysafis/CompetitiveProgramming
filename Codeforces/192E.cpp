/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Maria Chrysafis (Olympia)
 */



#include <iostream>
#include <fstream>
#include <vector>
#include <map>
#include <set>
#include <iomanip>
#include <algorithm>
#include <unordered_map>
#include <unordered_set>
#include <queue>
#include <string>
#include <random>
using namespace std;
class EFoolsAndRoads {
public:
    struct Tree {
        vector<vector<int>> adj;
        vector<vector<int>> dp;
        vector<int> parent;
        vector<int> start, end, depth;
        int cntr = 0;
        void memoize (int curNode, int prevNode) {
            start[curNode] = cntr++;
            parent[curNode] = prevNode;
            if (curNode == 0) {
                depth[curNode] = 0;
            } else {
                depth[curNode] = depth[prevNode] + 1;
            }
            for (int i: adj[curNode]) {
                if (i == prevNode) {
                    continue;
                }
                memoize(i, curNode);
            }
            end[curNode] = cntr++;
        }
        int isAncestor (int u, int v) {
            return (start[u] <= start[v] && end[u] >= end[v]);
        }
        int lca (int u, int v) {
            if (isAncestor(u, v)) {
                return u;
            }
            if (isAncestor(v, u)) {
                return v;
            }
            for (int i = 19; i >= 0; i--) {
                if (!isAncestor(dp[u][i], v)) {
                    u = dp[u][i];
                }
            }
            return dp[u][0];
        }
        void read(){
            depth.resize(adj.size());
            dp.resize(adj.size());
            parent.resize(adj.size());
            start.resize(adj.size()), end.resize(adj.size());
            for (int i = 0; i < adj.size(); i++) {
                dp[i].resize(20);
                for (int j = 0; j < dp[i].size(); j++) {
                    dp[i][j] = 0;
                }
            }
            memoize(0, -1);
            for (int j = 0; j < 20; j++) {
                for (int i = 0; i < adj.size(); i++) {
                    if (j == 0) {
                        dp[i][j] = parent[i];
                        if (dp[i][j] == -1) dp[i][j] = 0;
                    } else {
                        dp[i][j] = dp[dp[i][j - 1]][j - 1];
                    }
                }
            }
        }
    };
    Tree g;
    vector<int> val;
    int rec (int curNode, int prevNode) {
        //val[curNode] = 0;
        for (int i: g.adj[curNode]) {
            if (i != prevNode) {
                val[curNode] += rec(i, curNode);
            }
        }
        return val[curNode];
    }
	void solve(std::istream& in, std::ostream& out) {
        ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        int n;
        in >> n;
        g.adj.resize(n);
        vector<pair<int,int>> vec;
        for (int i = 0; i < n - 1; i++) {
            int u, v;
            in >> u >> v;
            u-- , v--;
            g.adj[u].push_back(v), g.adj[v].push_back(u);
            vec.emplace_back(u, v);
        }
        g.read();
        val.assign(n, 0);
        int q;
        in >> q;
        while (q--) {
            int u, v;
            in >> u >> v;
            u--, v--;
            val[u]++;
            val[v]++;
            val[g.lca(u, v)] -= 2;
        }
        rec(0, -1);
        for (auto&v : vec) {
            if (g.depth[v.first] < g.depth[v.second]) {
                out << val[v.second] << ' ';
            } else {
                out << val[v.first] << ' ';
            }
        }
	}
};


int main() {
	EFoolsAndRoads solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
