/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Maria Chrysafis
 */



#include <iostream>
#include <fstream>
#include <vector>
#include <map>
#include <set>
#include <iomanip>
#include <algorithm>
#include <unordered_map>
#include <unordered_set>
#include <queue>
#include <string>
#include <random>

using namespace std;

int myrandom(int i) { return std::rand() % i; }

class EClearingUp {
public:
    struct dsu {
        vector<int> parent;
        vector<long long> compSize;
        int n;

        void fill() {
            parent.resize(n), compSize.resize(n);
            for (int i = 0; i < n; i++) {
                parent[i] = i, compSize[i] = 1;
            }
        }

        int find_head(int x) {
            if (x == parent[x]) {
                return x;
            }
            return find_head(parent[x]);
        }

        void join(int x, int y) {
            x = find_head(x);
            y = find_head(y);
            if (x == y) {
                return;
            }
            if (compSize[x] > compSize[y]) {
                swap(x, y);
            }
            parent[x] = y;
            compSize[y] += compSize[x];
        }
    };

    struct Edge {
        int u, v;
        char col;
    };

    void solve(std::istream &in, std::ostream &out) {
        ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        int n, m;
        in >> n >> m;
        vector<pair<int,Edge>> edges;
        dsu d;
        d.n = n;
        d.fill();
        for (int i = 0; i < m; i++) {
            int u, v;
            in >> u >> v;
            u--, v--;
            char c;
            in >> c;
            edges.push_back({i, {u, v, c}});
            if (c == 'S') {
                d.join(u, v);
            }
        }
        if (n % 2 == 0) {
            out << "-1\n";
            return;
        }
        vector<int> taken;
        vector<bool> vis;
        vis.assign(m, false);
        for (auto p: edges) {
            if (p.second.col == 'M' && d.find_head(p.second.u) != d.find_head(p.second.v)) {
                d.join(p.second.u, p.second.v);
                taken.push_back(p.first);
                vis[p.first] = true;
            }
        }
        if (taken.size() > n/2) {
            out << "-1\n";
            return;
        }
        d.fill();
        for (int i = 0; i < vis.size(); i++) {
            if (vis[i]) {
                d.join(edges[i].second.u, edges[i].second.v);
            }
        }
        for (auto p: edges) {
            if (taken.size() + 1 <= n/2 && p.second.col == 'M' && d.find_head(p.second.u) != d.find_head(p.second.v)) {
                d.join(p.second.u, p.second.v);
                taken.push_back(p.first);
            }
        }
        for (auto p: edges) {
            if (taken.size() + 1 <= n && p.second.col == 'S' && d.find_head(p.second.u) != d.find_head(p.second.v)) {
                d.join(p.second.u, p.second.v);
                taken.push_back(p.first);
            }
        }
        if (taken.size() + 1 != n) {
            out << -1;
            return;
        }
        int santa = 0;
        int elf = 0;
        for (int i: taken) {
            if (edges[i].second.col == 'S') santa++;
            else elf++;
        }
        if (santa != elf) {
            out << -1;
            return;
        }
        out << taken.size() << '\n';
        for (int i: taken) {
            out << i + 1 << ' ';
        }
        out << '\n';
    }
};


int main() {
	EClearingUp solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
